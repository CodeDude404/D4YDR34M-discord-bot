// Generated by CoffeeScript 2.6.1
/*
 * node-liblzma - Node.js bindings for liblzma
 * Copyright (C) Olivier Orabona <olivier.orabona@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
var Transform, Unxz, Xz, XzStream, assert, binding_path, liblzma, maxThreads, os, path, util, xzBuffer, xzBufferSync;

path = require('path');

binding_path = path.resolve(path.join(__dirname, '..'));

liblzma = require('node-gyp-build')(binding_path);

util = require('util');

assert = require('assert');

os = require('os');

({Transform} = require('stream'));

// Should not change over time... :)
maxThreads = os.cpus().length;

XzStream = class XzStream extends Transform {
  constructor(mode, _opts = {}, options) {
    var base, base1, base2, base3, base4;
    super(options);
    this._opts = _opts;
    if ((base = this._opts).check == null) {
      base.check = exports.check.NONE;
    }
    if ((base1 = this._opts).preset == null) {
      base1.preset = exports.preset.DEFAULT;
    }
    if ((base2 = this._opts).filters == null) {
      base2.filters = [exports.filter.LZMA2];
    }
    if ((base3 = this._opts).mode == null) {
      base3.mode = exports.mode.NORMAL;
    }
    if ((base4 = this._opts).threads == null) {
      base4.threads = 1;
    }
    this._chunkSize = this._opts.chunkSize ? this._opts.chunkSize : liblzma.BUFSIZ;
    // By default no flush, since there is no LZMA_NO_SYNC, we stick to
    // default LZMA_RUN (0)
    this._flushFlag = this._opts.flushFlag || liblzma.LZMA_RUN;
    assert(Array.isArray(this._opts.filters), "Filters need to be in an array!");
    // Add default filter LZMA2 if none provided
    if (this._opts.filters.indexOf(exports.filter.LZMA2) === -1) {
      this._opts.filters.push(exports.filter.LZMA2);
    }
    // Multithreading is only available for encoding, so if we are encoding, check
    // opts threads value.
    if (mode === liblzma.STREAM_ENCODE) {
      if (!liblzma.HAS_THREADS_SUPPORT) {
        this._opts.threads = 1;
      }
      // By default set to maximum available processors
      if (this._opts.threads === 0) {
        this._opts.threads = maxThreads;
      }
    }
    // Initialize engine
    this.lzma = new liblzma.LZMA(mode, this._opts);
    this._closed = false;
    this._hadError = false;
    this._offset = 0;
    this._buffer = Buffer.alloc(this._chunkSize);
    this.on('onerror', (errno) => {
      var error;
      this._hadError = true;
      error = new Error(exports.messages[errno]);
      error.errno = errno;
      error.code = errno;
      return this.emit('error', error);
    });
    this.once('end', this.close);
  }

  flush(kind, callback) {
    var ws;
    ws = this._writableState;
    if (typeof kind === 'function' || (typeof kind === 'undefined' && !callback)) {
      [callback, kind] = [kind, liblzma.LZMA_SYNC_FLUSH];
    }
    if (ws.ended) {
      if (callback) {
        process.nextTick(callback);
      }
    } else if (ws.ending) {
      if (callback) {
        this.once('end', callback);
      }
    } else if (ws.needDrain) {
      this.once('drain', () => {
        this.flush(callback);
      });
    } else {
      this._flushFlag = kind;
      this.write(Buffer.alloc(0), '', callback);
    }
  }

  close(callback) {
    if (callback) {
      process.nextTick(callback);
    }
    // We will trigger this case with #xz and #unxz
    if (this._closed) {
      return;
    }
    this.lzma.close();
    this._closed = true;
    process.nextTick(() => {
      this.emit('close');
    });
  }

  _transform(chunk, encoding, callback) {
    var ending, flushFlag, last, ws;
    flushFlag = void 0;
    ws = this._writableState;
    ending = ws.ending || ws.ended;
    last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !(chunk instanceof Buffer)) {
      return callback(new Error("invalid input"));
    }
    if (this._closed) {
      return callback(new Error("lzma binding closed"));
    }
    // If it's the last chunk, or a final flush, we use the LZMA_FINISH flush flag.
    // If it's explicitly flushing at some other time, then we use
    // LZMA_SYNC_FLUSH.
    if (last) {
      flushFlag = liblzma.LZMA_FINISH;
    } else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        // once we've flushed the last of the queue, stop flushing and
        // go back to the normal behavior.
        this._flushFlag = this._opts.flushFlag || liblzma.LZMA_RUN;
      }
    }
    this._processChunk(chunk, flushFlag, callback);
  }

  _flush(callback) {
    this._transform(Buffer.alloc(0), '', callback);
  }

  _processChunk(chunk, flushFlag, cb) {
    var async, availInBefore, availOutBefore, buf, buffers, callback, error, inOff, nread, res;
    // If user setting async is set to true, then it will all depend on whether
    // we can actually be async, or not. If user set explicitly async to false
    // then whether we have a callback or not becomes irrelevant..
    // TODO: Works in v0.11
    //async = util.isFunction cb
    // until then...
    async = typeof cb === 'function';
    // Sanity checks
    assert(!this._closed, "Stream closed!");
    availInBefore = chunk && chunk.length;
    availOutBefore = this._chunkSize - this._offset;
    inOff = 0;
    // So far it looks like Zlib _processChunk in CoffeeScript. But to make C++
    // code easier when it comes to emitting events and callback calling sync/async
    // we handle error codes here. If anything wrong is returned, we emit event
    // and return false in case we are synchronous.
    callback = (errno, availInAfter, availOutAfter) => {
      var out, used;
      if (this._hadError) {
        return;
      }
      // if LZMA engine returned something else, we are running into trouble!
      if (errno !== liblzma.LZMA_OK && errno !== liblzma.LZMA_STREAM_END) {
        this.emit('onerror', errno);
        return false;
      }
      used = availOutBefore - availOutAfter;
      assert(used >= 0, `More bytes after than before! Delta = ${used}`);
      if (used > 0) {
        out = this._buffer.slice(this._offset, this._offset + used);
        this._offset += used;
        if (async) {
          this.push(out);
        } else {
          buffers.push(out);
          nread += used;
        }
      }
      // exhausted the output buffer, or used all the input create a new one.
      if (availOutAfter === 0 || this._offset >= this._chunkSize) {
        availOutBefore = this._chunkSize;
        this._offset = 0;
        this._buffer = Buffer.alloc(this._chunkSize);
      }
      if (availOutAfter === 0 || availInAfter > 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) {
          return true;
        }
        this.lzma.code(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, callback);
        return;
      }
      if (!async) {
        return false;
      }
      cb();
    };
    if (!async) {
      // Doing it synchronously
      buffers = [];
      nread = 0;
      error = null;
      this.on('error', function(e) {
        return error = e;
      });
      while (true) {
        res = this.lzma.codeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset);
        if (!(!this._hadError && callback(res[0], res[1], res[2]))) {
          break;
        }
      }
      if (this._hadError) {
        throw error;
      }
      this.close();
      buf = Buffer.concat(buffers, nread);
      return buf;
    }
    this.lzma.code(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, callback);
  }

};

Xz = class Xz extends XzStream {
  constructor(lzma_options, options) {
    super(liblzma.STREAM_ENCODE, lzma_options, options);
  }

};

Unxz = class Unxz extends XzStream {
  constructor(lzma_options, options) {
    super(liblzma.STREAM_DECODE, lzma_options, options);
  }

};

exports.Xz = Xz;

exports.Unxz = Unxz;

exports.hasThreads = function() {
  return liblzma.HAS_THREADS_SUPPORT;
};

exports.messages = ["Operation completed successfully", "End of stream was reached", "Input stream has no integrity check", "Cannot calculate the integrity check", "Integrity check type is not available", "Cannot allocate memory", "Memory usage limit was reached", "File format not recognized", "Invalid or unsupported options", "Data is corrupt", "No progress is possible", "Programming error"];

exports.check = {
  "NONE": liblzma.LZMA_CHECK_NONE,
  "CRC32": liblzma.LZMA_CHECK_CRC32,
  "CRC64": liblzma.LZMA_CHECK_CRC64,
  "SHA256": liblzma.LZMA_CHECK_SHA256
};

exports.preset = {
  "DEFAULT": liblzma.LZMA_PRESET_DEFAULT,
  "EXTREME": liblzma.LZMA_PRESET_EXTREME
};

exports.flag = {
  "TELL_NO_CHECK": liblzma.LZMA_TELL_NO_CHECK,
  "TELL_UNSUPPORTED_CHECK": liblzma.LZMA_TELL_UNSUPPORTED_CHECK,
  "TELL_ANY_CHECK": liblzma.LZMA_TELL_ANY_CHECK,
  "CONCATENATED": liblzma.LZMA_CONCATENATED
};

exports.filter = {
  "LZMA2": liblzma.LZMA_FILTER_LZMA2,
  "X86": liblzma.LZMA_FILTER_X86,
  "POWERPC": liblzma.LZMA_FILTER_POWERPC,
  "IA64": liblzma.LZMA_FILTER_IA64,
  "ARM": liblzma.LZMA_FILTER_ARM,
  "ARMTHUMB": liblzma.LZMA_FILTER_ARMTHUMB,
  "SPARC": liblzma.LZMA_FILTER_SPARC
};

exports.mode = {
  "FAST": liblzma.LZMA_MODE_FAST,
  "NORMAL": liblzma.LZMA_MODE_NORMAL
};

exports.createXz = function(lzma_options, options) {
  return new Xz(lzma_options, options);
};

exports.createUnxz = function(lzma_options, options) {
  return new Unxz(lzma_options, options);
};

exports.unxz = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    [callback, opts] = [opts, {}];
  }
  return xzBuffer(new Unxz(opts), buffer, callback);
};

exports.unxzSync = function(buffer, opts) {
  return xzBufferSync(new Unxz(opts), buffer);
};

exports.xz = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    [callback, opts] = [opts, {}];
  }
  return xzBuffer(new Xz(opts), buffer, callback);
};

exports.xzSync = function(buffer, opts) {
  return xzBufferSync(new Xz(opts), buffer);
};

xzBuffer = function(engine, buffer, callback) {
  var buffers, flow, nread, onEnd, onError;
  buffers = [];
  nread = 0;
  flow = function() {
    var chunk;
    chunk = void 0;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  };
  onEnd = function() {
    var buf;
    buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  };
  onError = function(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  };
  engine.on('error', onError);
  engine.on('end', onEnd);
  engine.end(buffer);
  flow();
};

xzBufferSync = function(engine, buffer) {
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer);
  }
  if (!(buffer instanceof Buffer)) {
    throw new TypeError("Not a string or buffer");
  }
  return engine._processChunk(buffer, liblzma.LZMA_FINISH);
};

module.exports = exports;
